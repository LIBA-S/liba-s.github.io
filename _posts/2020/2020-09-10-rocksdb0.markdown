---
layout: "post"
title: "flush"
date: "2020-09-10 14:15"
---
```c++
Status DBImpl::FlushMemTableToOutputFile(
    ColumnFamilyData* cfd, const MutableCFOptions& mutable_cf_options,
    bool* made_progress, JobContext* job_context, LogBuffer* log_buffer) {
  FlushJob job;
  job.PickMemTable();

  NotifyOnFlushBegin();

  if (logfile_number_ > 0 &&
    versions_->GetColumnFamilySet()->NumberOfColumnFamilies() > 0) {
  // If there are more than one column families, we need to make sure that
  // all the log files except the most recent one are synced. Otherwise if
  // the host crashes after flushing and before WAL is persistent, the
  // flushed SST may contain data from write batches whose updates to
  // other column families are missing.
  // SyncClosedLogs() may unlock and re-lock the db_mutex.
    s = SyncClosedLogs(job_context);
  }

  jon.Run();

  InstallSuperVersionAndScheduleWork();
}
```

WriteImpl
```
PreprocessWrite:
1.
2. 检查write buffer是否写满。如果写满，则调用HandleWriteBufferFull
```

```
HandleWriteBufferFull:
1. 选择一个正在使用memtable的cf。
2. 针对选取的cf，执行SwitchMemtable操作。
```

```c++
Status DBImpl::SwitchMemtable(ColumnFamilyData* cfd,
                              WriteContext* context,
                              FlushReason flush_reason) {
  // 1. 获取最新的CFOptions，如果log_empty_ = false, 则创建新的WAL文件
  // log_empty_用于控制two_write_queue情况下，并发创建的WAL的问题
  const MutableCFOptions mutable_cf_options = *cfd->GetLatestMutableCFOptions();

  // 2. 根据当前的write_buffer_size等配置预分配WAL(fallocate)
  int num_imm_unflushed = cfd->imm()->NumNotFlushed();
DBOptions db_options =
    BuildDBOptions(immutable_db_options_, mutable_db_options_);
const auto preallocate_block_size =
  GetWalPreallocateBlockSize(mutable_cf_options.write_buffer_size);
  // 3. 创建WAL文件成功之后，构建新的memtable，更新superversion，
  // 并尝试调度flush/compaction
  if (create wal success) {
    SequenceNumber seq = versions_->LastSequence();
    new_mem = cfd->ConstructNewMemtable(mutable_cf_options, seq);
    context->superversion_context.NewSuperVersion();
  }
  for (auto loop_cfd : *versions_->GetColumnFamilySet()) {
  // all this is just optimization to delete logs that
  // are no longer needed -- if CF is empty, that means it
  // doesn't need that particular log to stay alive, so we just
  // advance the log number. no need to persist this in the manifest
  if (loop_cfd->mem()->GetFirstSequenceNumber() == 0 &&
      loop_cfd->imm()->NumNotFlushed() == 0) {
    if (creating_new_log) {
      loop_cfd->SetLogNumber(logfile_number_);
    }
    loop_cfd->mem()->SetCreationSeq(versions_->LastSequence());
  }
}

 cfd->imm()->Add(cfd->mem(), &context->memtables_to_free_);
 new_mem->Ref();
 cfd->SetMemtable(new_mem);
 InstallSuperVersionAndScheduleWork(cfd, &context->superversion_context,
                                   mutable_cf_options, flush_reason);
 return s;
}
```

```c++
void DBImpl::InstallSuperVersionAndScheduleWork(
    ColumnFamilyData* cfd, SuperVersionContext* sv_context,
    const MutableCFOptions& mutable_cf_options, FlushReason flush_reason) {
      mutex_.AssertHeld();

// Update max_total_in_memory_state_
size_t old_memtable_size = 0;
auto* old_sv = cfd->GetSuperVersion();
if (old_sv) {
  old_memtable_size = old_sv->mutable_cf_options.write_buffer_size *
                      old_sv->mutable_cf_options.max_write_buffer_number;
}

if (sv_context->new_superversion == nullptr) {
  sv_context->NewSuperVersion();
}


cfd->InstallSuperVersion(sv_context, &mutex_, mutable_cf_options);

// Whenever we install new SuperVersion, we might need to issue new flushes or
// compactions.
SchedulePendingFlush(cfd, flush_reason);
SchedulePendingCompaction(cfd);
MaybeScheduleFlushOrCompaction();

// Update max_total_in_memory_state_
max_total_in_memory_state_ = max_total_in_memory_state_ - old_memtable_size +
                             mutable_cf_options.write_buffer_size *
                                 mutable_cf_options.max_write_buffer_number;
}
```

```c++
void ColumnFamilyData::InstallSuperVersion(
    SuperVersionContext* sv_context, InstrumentedMutex* db_mutex,
    const MutableCFOptions& mutable_cf_options) {
      // 更新当前cf最新的mem(Memtable*), imm(MemtableListVersion*)和sst文件(Version*)视图
      SuperVersion* new_superversion = sv_context->new_superversion.release();
      new_superversion->db_mutex = db_mutex;
      new_superversion->mutable_cf_options = mutable_cf_options;
      new_superversion->Init(mem_, imm_.current(), current_);
      SuperVersion* old_superversion = super_version_;
      super_version_ = new_superversion;
      ++super_version_number_;
      super_version_->version_number = super_version_number_;
      super_version_->write_stall_condition =
          RecalculateWriteStallConditions(mutable_cf_options);

      if (old_superversion != nullptr) {
      // Reset SuperVersions cached in thread local storage.
      // This should be done before old_superversion->Unref(). That's to ensure
      // that local_sv_ never holds the last reference to SuperVersion, since
      // it has no means to safely do SuperVersion cleanup.
      ResetThreadLocalSuperVersions();

      // 如果当前最新的write_buffer_size发生了改变，则应用到当前的memtable属性上
      if (old_superversion->mutable_cf_options.write_buffer_size !=
          mutable_cf_options.write_buffer_size) {
        mem_->UpdateWriteBufferSize(mutable_cf_options.write_buffer_size);
      }
      if (old_superversion->write_stall_condition !=
          new_superversion->write_stall_condition) {
        sv_context->PushWriteStallNotification(
            old_superversion->write_stall_condition,
            new_superversion->write_stall_condition, GetName(), ioptions());
      }
      // 如果没有更多引用当前superversion，则清理它：
      // unref memtable, immutable memtable, version
      if (old_superversion->Unref()) {
        old_superversion->Cleanup();
        sv_context->superversions_to_free.push_back(old_superversion);
      }
    }
}
```
